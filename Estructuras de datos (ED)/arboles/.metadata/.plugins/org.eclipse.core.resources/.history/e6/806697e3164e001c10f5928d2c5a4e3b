/**
 * 
 */
package ColasPrioridad;

/**
 * @author blanc
 *
 */
public class BinaryHeapMin<T extends Comparable<T>> implements PriorityQueue<T> {

	private T[] monticulo;
	private int numElementos;

	@SuppressWarnings("unchecked")
	public BinaryHeapMin(int n) {
		setMonticulo((T[]) new Object[n]);
		setNumElementos(n);
	}

	@Override
	public int add(T elemento) {
		// -2 null
		//-1 no cabe
		//0 si lo puede insertar
		return 0;
	}

	@Override
	//sacar*
	public T poll() {
		// devuelve el elem de la pos 0
		//y lo borra <- coger lo de la ultima pos y colocarlo en la pos 0
		//sino devuelve null
		return null;
	}

	@Override
	//identico a sacar
	//parte de la posición parámetro
	//-2 si elem es null o monticulo está vacío
	//-1 si el elemento no existe en el montículo
	//0 si lo borra
	public int remove(T elemento) {
		// TODO Auto-generated method stub
		return 0;
	}

	
	@Override
	public boolean isEmpty() {
		if(this.numElementos == 0) {
			return true;
		}
		return false;
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub

	}

	@Override
	public int cambiarPrioridad(int pos, T elemento) {
		// TODO Auto-generated method stub
		return 0;
	}

	public T[] getMonticulo() {
		return monticulo;
	}

	public void setMonticulo(T[] monticulo) {
		this.monticulo = monticulo;
	}

	public int getNumElementos() {
		return numElementos;
	}

	public void setNumElementos(int numElementos) {
		this.numElementos = numElementos;
	}
	
	//averigua los hijos
	//comprobar pos válidas(dentro del vector)
	//hay algo en esas pposiciones? sino no tiene hijos
	//si hay algo coger el más pequeño
	private void filtradoAscendente(int pos) {}
	
	
	private void filtradoDescendente(int pos) {}

}
