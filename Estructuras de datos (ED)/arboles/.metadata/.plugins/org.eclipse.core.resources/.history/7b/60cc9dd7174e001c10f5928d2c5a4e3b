/**
 * 
 */
package ColasPrioridad;

/**
 * @author blanc
 *
 */
public class BinaryHeapMin<T extends Comparable<T>> implements PriorityQueue<T> {

	private T[] monticulo;
	private int numElementos;

	@SuppressWarnings("unchecked")
	public BinaryHeapMin(int n) {
		setMonticulo((T[]) new Object[n]);
		setNumElementos(n);
	}

	@Override
	// -2 null
	// -1 no cabe
	// 0 si lo puede insertar
	public int add(T elemento) {
		if (elemento == null) {
			return -2;
		} else if (this.numElementos == this.monticulo.length) {
			return -1;
		} else {
			this.numElementos++;
			this.monticulo[this.numElementos - 1] = elemento;
		}
		return 0;
	}

	@Override
	// sacar*
	public T poll() {
		// devuelve el elem de la pos 0
		// y lo borra <- coger lo de la ultima pos y colocarlo en la pos 0
		// sino devuelve null
		return null;
	}

	@Override
	// identico a sacar
	// parte de la posición parámetro
	// -2 si elem es null o monticulo está vacío
	// -1 si el elemento no existe en el montículo
	// 0 si lo borra
	public int remove(T elemento) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public boolean isEmpty() {
		if (this.numElementos == 0) {
			return true;
		}
		return false;
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub

	}

	@Override
	public String toString() {
		return null;
	}

	@Override
	// busca el elem, lo compara
	// si es menor, filtrado ascendente
	// si es mayor filtrado descendente
	public int cambiarPrioridad(int pos, T elemento) {
		// -2 si la pos es negativa o fuera del vector o el elemento es null
		// -1 si la cola está vacía
		// 0 si se inserta correctamente
		return 0;
	}

	public T[] getMonticulo() {
		return monticulo;
	}

	private void setMonticulo(T[] monticulo) {
		this.monticulo = monticulo;
	}

	public int getNumElementos() {
		return numElementos;
	}

	private void setNumElementos(int numElementos) {
		this.numElementos = numElementos;
	}

	// averigua los hijos
	// comprobar pos válidas(dentro del vector)
	// hay algo en esas pposiciones? sino no tiene hijos
	// si hay algo coger el más pequeño
	private void filtradoAscendente(int pos) {
	}

	private void filtradoDescendente(int pos) {
	}

}
