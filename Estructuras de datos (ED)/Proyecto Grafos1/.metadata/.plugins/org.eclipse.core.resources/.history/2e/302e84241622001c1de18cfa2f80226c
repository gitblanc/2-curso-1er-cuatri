import java.text.DecimalFormat;

/**
 * 
 */

/**
 * @author blanc
 *
 */
public class Graph<T> {
	private double[][] weights; // pesos de las aristas
	private boolean[][] edges; // matriz de aristas
	private T[] nodes; // nodos
	private int size; // numero de vértices o tamaño útil

	@SuppressWarnings("unchecked")
	public Graph(int dimension) {
		this.nodes = (T[]) new Object[dimension];
		this.weights = new double[dimension][dimension];
		this.edges = new boolean[dimension][dimension];
		this.size = 0; // no hay vértices
	}

	public int getSize() {
		return this.size;
	}

	protected int getNode(T node) {
		for (int i = 0; i < nodes.length; i++) {
			if (node.equals(nodes[i])) {
				return i;
			}
		}
		return -1;
	}

	public boolean existsNode(T node) {
		int pos = getNode(node);
		if (pos == -1)
			return false;
		else
			return true;
	}

	public int addNode(T node) {
		if (size < nodes.length && getNode(node) == -1) {
			nodes[size] = node;
			for (int i = 0; i <= size; i++) {
				edges[size][i] = false;
				edges[i][size] = false;
				weights[size][i] = 0;
				weights[i][size] = 0;
			}
			++size;
			return 0;
		}else if(existsNode(node) && size >= nodes.length) {
			return -3;
		}else if(existsNode(node) && size < nodes.length) {
			return -1;
		}else if(!existsNode(node) && size < nodes.length) {
			return -2;
		}else {
			return -4;
		}
	}

	public boolean existsEdge(T source, T target) {
		int i = getNode(source);
		int j = getNode(target);
		if (i >= 0 && j >= 0)
			return edges[i][j];
		else
			return false;
	}

	public double getEdge(T source, T target) {
		int i = getNode(source);
		int j = getNode(target);

		if (i >= 0 && j >= 0) {
			return weights[i][j];
		} else if (i == -1 && j >= 0) {
			return -1;
		} else if (i >= 0 && j == -1) {
			return -2;
		} else if (i == -1 && j == -1) {
			return -3;
		} else {
			return -4;
		}
	}

	public int addEdge(T source, T target, double weight) {
		int i = getNode(source);
		int j = getNode(target);
		if (i >= 0 && j >= 0) {
			edges[i][j] = true;
			weights[i][j] = weight;
			return 0;
		} else if (i == -1 && j >= 0) {
			return -1;
		} else if (i >= 0 && j == -1) {
			return -2;
		} else if (i == -1 && j == -1) {
			return -3;
		} else if (getEdge(source, target) >= 0) {
			return -4;
		} else {
			return -8;
		}
	}

	public int removeEdge(T source, T target) {
		int x = 0;
		int k = 0;
		if (existsEdge(source, target)) {
			int i = getNode(source);
			int j = getNode(target);
			x = i;
			k = j;

			edges[i][j] = false;
			weights[i][j] = 0;
			return 0;
		} else if (x == -1 && k >= 0) {
			return -1;
		} else if (x >= 0 && k == -1) {
			return -2;
		} else if (x == -1 && k == -1) {
			return -3;
		} else {
			return -4;
		}
	}

	public int removeNode(T node) {
		int i = getNode(node);

		if (i >= 0) {
			--size;
			if (i != size + 1) { // no es el último nodo
				nodes[i] = nodes[size];
			}

			for (int j = 0; j <= size; j++) {
				edges[j][i] = edges[j][size];
				edges[i][j] = edges[size][j];
				weights[i][j] = weights[size][j];
				weights[j][i] = weights[j][size];
			}
			edges[i][i] = edges[size][size]; // elimina el codo
			weights[i][i] = weights[size][size];
			return 0;
		}
		return -1;
	}
	
	public String toString() { 
		DecimalFormat df = new DecimalFormat("#.##");
		String cadena = "";
		cadena += "NODOS\n";
		for (int i = 0; i < size; i++) {
		cadena += nodes[i].toString() + "\t";
		}
		cadena += "\n\nARISTAS\n";
		for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
		if (edges[i][j])
		cadena += "T\t";
		else
		cadena += "F\t";
		}
		cadena += "\n";
		}
		cadena += "\nPESOS\n";
		for (int i = 0; i < size; i++) {
		for (int j = 0; j < size; j++) {
		cadena += (edges[i][j] ? df.format(weights[i][j]) : "-") + "\t";
		}
		cadena += "\n";
		}
		return cadena;
		}

	
}
