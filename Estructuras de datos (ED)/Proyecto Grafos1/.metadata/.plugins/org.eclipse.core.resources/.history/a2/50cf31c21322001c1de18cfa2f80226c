
/**
 * 
 */

/**
 * @author blanc
 *
 */
public class Graph<T> {
	private double[][] weights; // pesos de las aristas
	private boolean[][] edges; // matriz de aristas
	private T[] nodes; // nodos
	private int size; // numero de vértices o tamaño útil

	public Graph(int dimension) {
		this.nodes = (T[]) new Object[dimension];
		this.weights = new double[dimension][dimension];
		this.edges = new boolean[dimension][dimension];
		this.size = 0; // no hay vértices
	}

	public int getSize() {
		return this.size;
	}

	protected int getNode(T node) {
		for (int i = 0; i < nodes.length; i++) {
			if (nodes[i].equals(node)) {
				return i;
			}
		}
		return -1;
	}

	public boolean existsNode(T node) {
		int pos = getNode(node);
		if (pos == -1)
			return false;
		else
			return true;
	}

	public int addNode(T node) {
		if (size < nodes.length && getNode(node) == -1) {
			nodes[size] = node;
			for (int i = 0; i <= size; i++) {
				edges[size][i] = false;
				edges[i][size] = false;
				weights[size][i] = 0;
				weights[i][size] = 0;
			}
			++size;
			return 0;
		} else if (existsNode(node) && size >= nodes.length) {
			return -3;
		} else if (existsNode(node) && size < nodes.length) {
			return -1;
		} else if (!existsNode(node) && size < nodes.length) {
			return -2;
		} else {
			return -4;
		}
	}

	public boolean existsEdge(T source, T target) {
		int i = getNode(source);
		int j = getNode(target);
		if (i >= 0 && j >= 0)
			return edges[i][j];
		else
			return false;
	}

	public double getEdge(T source, T target) {
		int i = getNode(source);
		int j = getNode(target);

		if (i >= 0 && j >= 0) {
			return weights[i][j];
		} else if (i == -1 && j >= 0) {
			return -1;
		} else if (i >= 0 && j == -1) {
			return -2;
		} else if (i == -1 && j == -1) {
			return -3;
		} else {
			return -4;
		}
	}

	public int addEdge(T source, T target, double weight) {
		int i = getNode(source);
		int j = getNode(target);
		if (i >= 0 && j >= 0) {
			edges[i][j] = true;
			weights[i][j] = weight;
			return 0;
		} else if (i == -1 && j >= 0) {
			return -1;
		} else if (i >= 0 && j == -1) {
			return -2;
		} else if (i == -1 && j == -1) {
			return -3;
		} else if (getEdge(source, target) >= 0) {
			return -4;
		} else {
			return -8;
		}
	}

	public int removeEdge(T source, T target) {
		int x = 0;
		int k = 0;
		if (existsEdge(source, target)) {
			int i = getNode(source);
			int j = getNode(target);
			x = i;
			k = j;

			edges[i][j] = false;
			weights[i][j] = 0;
			return 0;
		} else if (x == -1 && k >= 0) {
			return -1;
		} else if (x >= 0 && k == -1) {
			return -2;
		} else if (x == -1 && k == -1) {
			return -3;
		} else {
			return -4;
		}
	}

	public int removeNode(T node) {
		int i = getNode(node);

		if (i >= 0) {
			--size;
			if (i != size + 1) { // no es el último nodo
				nodes[i] = nodes[size];
			}

			for (int j = 0; j <= size; j++) {
				edges[j][i] = edges[j][size];
				edges[i][j] = edges[size][j];
				weights[i][j] = weights[size][j];
				weights[j][i] = weights[j][size];
			}
			edges[i][i] = edges[size][size]; // elimina el codo
			weights[i][i] = weights[size][size];
			return 0;
		}
		return -1;
	}

	public
	String toString () {
	DecimalFormat
	df = new DecimalFormat ("#.##");
	String
	cadena = "";
	cadena += "
	NODOS n ";
	for
	int i = 0; i < numNodes ; i++) {
	cadena +=
	nodes [ toString () + t";
	}
	cadena += "
	n nARISTAS n ";
	for
	int i = 0; i < numNodes ; i++) {
	for
	int j = 0; j < numNodes ; j++j++) {
	if
	edges [i][j])
	cadena += "T
	t";
	else
	cadena += "F
	t";
	}
	cadena += "
	n";
	}
	cadena += "
	nPESOS n ";
	for
	int i = 0; i < numNodes ; i++) {
	for
	int j = 0; j < numNodes ; j++j++) {
	cadena += (
	edges [i][ df.format weights [i][ j]):"--") + t";
	}
	cadena += "
	n";
	}
	return
	cadena;
	}
}
